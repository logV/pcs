// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal.proto

/*
	Package internalpb is a generated protocol buffer package.

	It is generated from these files:
		internal.proto

	It has these top-level messages:
		FlagDefs
*/
package internalpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type FlagDefs struct {
	OP string `protobuf:"bytes,1,opt,name=OP,proto3" json:"OP,omitempty"`
	// print results out
	PRINT bool `protobuf:"varint,2,opt,name=PRINT,proto3" json:"PRINT,omitempty"`
	// save records that match filter to tsv files
	EXPORT bool `protobuf:"varint,3,opt,name=EXPORT,proto3" json:"EXPORT,omitempty"`
	// list the tables in the db dir
	LIST_TABLES bool `protobuf:"varint,4,opt,name=LIST_TABLES,json=LISTTABLES,proto3" json:"LIST_TABLES,omitempty"`
	// for usage with distributed queries
	// load query flags from stdin as gob encoded data
	DECODE_FLAGS bool `protobuf:"varint,5,opt,name=DECODE_FLAGS,json=DECODEFLAGS,proto3" json:"DECODE_FLAGS,omitempty"`
	// print the query flags to stdout as binary
	ENCODE_FLAGS bool `protobuf:"varint,6,opt,name=ENCODE_FLAGS,json=ENCODEFLAGS,proto3" json:"ENCODE_FLAGS,omitempty"`
	// print the querySpec results to stdout as binary
	ENCODE_RESULTS bool   `protobuf:"varint,7,opt,name=ENCODE_RESULTS,json=ENCODERESULTS,proto3" json:"ENCODE_RESULTS,omitempty"`
	INT_FILTERS    string `protobuf:"bytes,8,opt,name=INT_FILTERS,json=INTFILTERS,proto3" json:"INT_FILTERS,omitempty"`
	STR_FILTERS    string `protobuf:"bytes,9,opt,name=STR_FILTERS,json=STRFILTERS,proto3" json:"STR_FILTERS,omitempty"`
	// regex replacement for strings
	STR_REPLACE string `protobuf:"bytes,10,opt,name=STR_REPLACE,json=STRREPLACE,proto3" json:"STR_REPLACE,omitempty"`
	SET_FILTERS string `protobuf:"bytes,11,opt,name=SET_FILTERS,json=SETFILTERS,proto3" json:"SET_FILTERS,omitempty"`
	INTS        string `protobuf:"bytes,12,opt,name=INTS,proto3" json:"INTS,omitempty"`
	STRS        string `protobuf:"bytes,13,opt,name=STRS,proto3" json:"STRS,omitempty"`
	GROUPS      string `protobuf:"bytes,14,opt,name=GROUPS,proto3" json:"GROUPS,omitempty"`
	DISTINCT    string `protobuf:"bytes,15,opt,name=DISTINCT,proto3" json:"DISTINCT,omitempty"`
	TIME        bool   `protobuf:"varint,16,opt,name=TIME,proto3" json:"TIME,omitempty"`
	TIME_COL    string `protobuf:"bytes,17,opt,name=TIME_COL,json=TIMECOL,proto3" json:"TIME_COL,omitempty"`
	// ve"rpbvebve"ry
	// ve"rpbvebve"ry
	// 20
	TIME_BUCKET        int    `protobuf:"varint,18,opt,name=TIME_BUCKET,json=TIMEBUCKET,proto3,customtype=int" json:"TIME_BUCKET"`
	HIST_BUCKET        int    `protobuf:"varint,19,opt,name=HIST_BUCKET,json=HISTBUCKET,proto3,customtype=int" json:"HIST_BUCKET"`
	LOG_HIST           bool   `protobuf:"varint,20,opt,name=LOG_HIST,json=LOGHIST,proto3" json:"LOG_HIST,omitempty"`
	FIELD_SEPARATOR    string `protobuf:"bytes,21,opt,name=FIELD_SEPARATOR,json=FIELDSEPARATOR,proto3" json:"FIELD_SEPARATOR,omitempty"`
	FILTER_SEPARATOR   string `protobuf:"bytes,22,opt,name=FILTER_SEPARATOR,json=FILTERSEPARATOR,proto3" json:"FILTER_SEPARATOR,omitempty"`
	LOAD_AND_QUERY     bool   `protobuf:"varint,23,opt,name=LOAD_AND_QUERY,json=LOADANDQUERY,proto3" json:"LOAD_AND_QUERY,omitempty"`
	READ_INGESTION_LOG bool   `protobuf:"varint,24,opt,name=READ_INGESTION_LOG,json=READINGESTIONLOG,proto3" json:"READ_INGESTION_LOG,omitempty"`
	READ_ROWSTORE      bool   `protobuf:"varint,25,opt,name=READ_ROWSTORE,json=READROWSTORE,proto3" json:"READ_ROWSTORE,omitempty"`
	SKIP_COMPACT       bool   `protobuf:"varint,26,opt,name=SKIP_COMPACT,json=SKIPCOMPACT,proto3" json:"SKIP_COMPACT,omitempty"`
	PROFILE            bool   `protobuf:"varint,27,opt,name=PROFILE,proto3" json:"PROFILE,omitempty"`
	PROFILE_MEM        bool   `protobuf:"varint,28,opt,name=PROFILE_MEM,json=PROFILEMEM,proto3" json:"PROFILE_MEM,omitempty"`
	RECYCLE_MEM        bool   `protobuf:"varint,29,opt,name=RECYCLE_MEM,json=RECYCLEMEM,proto3" json:"RECYCLE_MEM,omitempty"`
	CACHED_QUERIES     bool   `protobuf:"varint,30,opt,name=CACHED_QUERIES,json=CACHEDQUERIES,proto3" json:"CACHED_QUERIES,omitempty"`
	WEIGHT_COL         string `protobuf:"bytes,31,opt,name=WEIGHT_COL,json=WEIGHTCOL,proto3" json:"WEIGHT_COL,omitempty"`
	LIMIT              int    `protobuf:"varint,32,opt,name=LIMIT,proto3,customtype=int" json:"LIMIT"`
	DEBUG              bool   `protobuf:"varint,33,opt,name=DEBUG,proto3" json:"DEBUG,omitempty"`
	JSON               bool   `protobuf:"varint,34,opt,name=JSON,proto3" json:"JSON,omitempty"`
	GC                 bool   `protobuf:"varint,35,opt,name=GC,proto3" json:"GC,omitempty"`
	DIR                string `protobuf:"bytes,36,opt,name=DIR,proto3" json:"DIR,omitempty"`
	SORT               string `protobuf:"bytes,37,opt,name=SORT,proto3" json:"SORT,omitempty"`
	PRUNE_BY           string `protobuf:"bytes,38,opt,name=PRUNE_BY,json=PRUNEBY,proto3" json:"PRUNE_BY,omitempty"`
	TABLE              string `protobuf:"bytes,39,opt,name=TABLE,proto3" json:"TABLE,omitempty"`
	PRINT_INFO         bool   `protobuf:"varint,40,opt,name=PRINT_INFO,json=PRINTINFO,proto3" json:"PRINT_INFO,omitempty"`
	SAMPLES            bool   `protobuf:"varint,41,opt,name=SAMPLES,proto3" json:"SAMPLES,omitempty"`
	UPDATE_TABLE_INFO  bool   `protobuf:"varint,42,opt,name=UPDATE_TABLE_INFO,json=UPDATETABLEINFO,proto3" json:"UPDATE_TABLE_INFO,omitempty"`
	SKIP_OUTLIERS      bool   `protobuf:"varint,43,opt,name=SKIP_OUTLIERS,json=SKIPOUTLIERS,proto3" json:"SKIP_OUTLIERS,omitempty"`
	// STATS
	ANOVA_ICC        bool `protobuf:"varint,44,opt,name=ANOVA_ICC,json=ANOVAICC,proto3" json:"ANOVA_ICC,omitempty"`
	WRITE_BLOCK_INFO bool `protobuf:"varint,45,opt,name=WRITE_BLOCK_INFO,json=WRITEBLOCKINFO,proto3" json:"WRITE_BLOCK_INFO,omitempty"`
	// If true protobuf encoding is used for flags.
	PROTO bool `protobuf:"varint,46,opt,name=PROTO,proto3" json:"PROTO,omitempty"`
}

func (m *FlagDefs) Reset()                    { *m = FlagDefs{} }
func (m *FlagDefs) String() string            { return proto.CompactTextString(m) }
func (*FlagDefs) ProtoMessage()               {}
func (*FlagDefs) Descriptor() ([]byte, []int) { return fileDescriptorInternal, []int{0} }

func (m *FlagDefs) GetOP() string {
	if m != nil {
		return m.OP
	}
	return ""
}

func (m *FlagDefs) GetPRINT() bool {
	if m != nil {
		return m.PRINT
	}
	return false
}

func (m *FlagDefs) GetEXPORT() bool {
	if m != nil {
		return m.EXPORT
	}
	return false
}

func (m *FlagDefs) GetLIST_TABLES() bool {
	if m != nil {
		return m.LIST_TABLES
	}
	return false
}

func (m *FlagDefs) GetDECODE_FLAGS() bool {
	if m != nil {
		return m.DECODE_FLAGS
	}
	return false
}

func (m *FlagDefs) GetENCODE_FLAGS() bool {
	if m != nil {
		return m.ENCODE_FLAGS
	}
	return false
}

func (m *FlagDefs) GetENCODE_RESULTS() bool {
	if m != nil {
		return m.ENCODE_RESULTS
	}
	return false
}

func (m *FlagDefs) GetINT_FILTERS() string {
	if m != nil {
		return m.INT_FILTERS
	}
	return ""
}

func (m *FlagDefs) GetSTR_FILTERS() string {
	if m != nil {
		return m.STR_FILTERS
	}
	return ""
}

func (m *FlagDefs) GetSTR_REPLACE() string {
	if m != nil {
		return m.STR_REPLACE
	}
	return ""
}

func (m *FlagDefs) GetSET_FILTERS() string {
	if m != nil {
		return m.SET_FILTERS
	}
	return ""
}

func (m *FlagDefs) GetINTS() string {
	if m != nil {
		return m.INTS
	}
	return ""
}

func (m *FlagDefs) GetSTRS() string {
	if m != nil {
		return m.STRS
	}
	return ""
}

func (m *FlagDefs) GetGROUPS() string {
	if m != nil {
		return m.GROUPS
	}
	return ""
}

func (m *FlagDefs) GetDISTINCT() string {
	if m != nil {
		return m.DISTINCT
	}
	return ""
}

func (m *FlagDefs) GetTIME() bool {
	if m != nil {
		return m.TIME
	}
	return false
}

func (m *FlagDefs) GetTIME_COL() string {
	if m != nil {
		return m.TIME_COL
	}
	return ""
}

func (m *FlagDefs) GetLOG_HIST() bool {
	if m != nil {
		return m.LOG_HIST
	}
	return false
}

func (m *FlagDefs) GetFIELD_SEPARATOR() string {
	if m != nil {
		return m.FIELD_SEPARATOR
	}
	return ""
}

func (m *FlagDefs) GetFILTER_SEPARATOR() string {
	if m != nil {
		return m.FILTER_SEPARATOR
	}
	return ""
}

func (m *FlagDefs) GetLOAD_AND_QUERY() bool {
	if m != nil {
		return m.LOAD_AND_QUERY
	}
	return false
}

func (m *FlagDefs) GetREAD_INGESTION_LOG() bool {
	if m != nil {
		return m.READ_INGESTION_LOG
	}
	return false
}

func (m *FlagDefs) GetREAD_ROWSTORE() bool {
	if m != nil {
		return m.READ_ROWSTORE
	}
	return false
}

func (m *FlagDefs) GetSKIP_COMPACT() bool {
	if m != nil {
		return m.SKIP_COMPACT
	}
	return false
}

func (m *FlagDefs) GetPROFILE() bool {
	if m != nil {
		return m.PROFILE
	}
	return false
}

func (m *FlagDefs) GetPROFILE_MEM() bool {
	if m != nil {
		return m.PROFILE_MEM
	}
	return false
}

func (m *FlagDefs) GetRECYCLE_MEM() bool {
	if m != nil {
		return m.RECYCLE_MEM
	}
	return false
}

func (m *FlagDefs) GetCACHED_QUERIES() bool {
	if m != nil {
		return m.CACHED_QUERIES
	}
	return false
}

func (m *FlagDefs) GetWEIGHT_COL() string {
	if m != nil {
		return m.WEIGHT_COL
	}
	return ""
}

func (m *FlagDefs) GetDEBUG() bool {
	if m != nil {
		return m.DEBUG
	}
	return false
}

func (m *FlagDefs) GetJSON() bool {
	if m != nil {
		return m.JSON
	}
	return false
}

func (m *FlagDefs) GetGC() bool {
	if m != nil {
		return m.GC
	}
	return false
}

func (m *FlagDefs) GetDIR() string {
	if m != nil {
		return m.DIR
	}
	return ""
}

func (m *FlagDefs) GetSORT() string {
	if m != nil {
		return m.SORT
	}
	return ""
}

func (m *FlagDefs) GetPRUNE_BY() string {
	if m != nil {
		return m.PRUNE_BY
	}
	return ""
}

func (m *FlagDefs) GetTABLE() string {
	if m != nil {
		return m.TABLE
	}
	return ""
}

func (m *FlagDefs) GetPRINT_INFO() bool {
	if m != nil {
		return m.PRINT_INFO
	}
	return false
}

func (m *FlagDefs) GetSAMPLES() bool {
	if m != nil {
		return m.SAMPLES
	}
	return false
}

func (m *FlagDefs) GetUPDATE_TABLE_INFO() bool {
	if m != nil {
		return m.UPDATE_TABLE_INFO
	}
	return false
}

func (m *FlagDefs) GetSKIP_OUTLIERS() bool {
	if m != nil {
		return m.SKIP_OUTLIERS
	}
	return false
}

func (m *FlagDefs) GetANOVA_ICC() bool {
	if m != nil {
		return m.ANOVA_ICC
	}
	return false
}

func (m *FlagDefs) GetWRITE_BLOCK_INFO() bool {
	if m != nil {
		return m.WRITE_BLOCK_INFO
	}
	return false
}

func (m *FlagDefs) GetPROTO() bool {
	if m != nil {
		return m.PROTO
	}
	return false
}

func init() {
	proto.RegisterType((*FlagDefs)(nil), "internalpb.FlagDefs")
}
func (m *FlagDefs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlagDefs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.OP)))
		i += copy(dAtA[i:], m.OP)
	}
	if m.PRINT {
		dAtA[i] = 0x10
		i++
		if m.PRINT {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EXPORT {
		dAtA[i] = 0x18
		i++
		if m.EXPORT {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LIST_TABLES {
		dAtA[i] = 0x20
		i++
		if m.LIST_TABLES {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DECODE_FLAGS {
		dAtA[i] = 0x28
		i++
		if m.DECODE_FLAGS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ENCODE_FLAGS {
		dAtA[i] = 0x30
		i++
		if m.ENCODE_FLAGS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ENCODE_RESULTS {
		dAtA[i] = 0x38
		i++
		if m.ENCODE_RESULTS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.INT_FILTERS) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.INT_FILTERS)))
		i += copy(dAtA[i:], m.INT_FILTERS)
	}
	if len(m.STR_FILTERS) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.STR_FILTERS)))
		i += copy(dAtA[i:], m.STR_FILTERS)
	}
	if len(m.STR_REPLACE) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.STR_REPLACE)))
		i += copy(dAtA[i:], m.STR_REPLACE)
	}
	if len(m.SET_FILTERS) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.SET_FILTERS)))
		i += copy(dAtA[i:], m.SET_FILTERS)
	}
	if len(m.INTS) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.INTS)))
		i += copy(dAtA[i:], m.INTS)
	}
	if len(m.STRS) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.STRS)))
		i += copy(dAtA[i:], m.STRS)
	}
	if len(m.GROUPS) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.GROUPS)))
		i += copy(dAtA[i:], m.GROUPS)
	}
	if len(m.DISTINCT) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.DISTINCT)))
		i += copy(dAtA[i:], m.DISTINCT)
	}
	if m.TIME {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.TIME {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TIME_COL) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.TIME_COL)))
		i += copy(dAtA[i:], m.TIME_COL)
	}
	if m.TIME_BUCKET != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.TIME_BUCKET))
	}
	if m.HIST_BUCKET != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.HIST_BUCKET))
	}
	if m.LOG_HIST {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.LOG_HIST {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FIELD_SEPARATOR) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.FIELD_SEPARATOR)))
		i += copy(dAtA[i:], m.FIELD_SEPARATOR)
	}
	if len(m.FILTER_SEPARATOR) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.FILTER_SEPARATOR)))
		i += copy(dAtA[i:], m.FILTER_SEPARATOR)
	}
	if m.LOAD_AND_QUERY {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.LOAD_AND_QUERY {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.READ_INGESTION_LOG {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.READ_INGESTION_LOG {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.READ_ROWSTORE {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.READ_ROWSTORE {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SKIP_COMPACT {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		if m.SKIP_COMPACT {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PROFILE {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.PROFILE {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PROFILE_MEM {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if m.PROFILE_MEM {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RECYCLE_MEM {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		if m.RECYCLE_MEM {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CACHED_QUERIES {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		if m.CACHED_QUERIES {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.WEIGHT_COL) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.WEIGHT_COL)))
		i += copy(dAtA[i:], m.WEIGHT_COL)
	}
	if m.LIMIT != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.LIMIT))
	}
	if m.DEBUG {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.DEBUG {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.JSON {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.JSON {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GC {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		if m.GC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DIR) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.DIR)))
		i += copy(dAtA[i:], m.DIR)
	}
	if len(m.SORT) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.SORT)))
		i += copy(dAtA[i:], m.SORT)
	}
	if len(m.PRUNE_BY) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.PRUNE_BY)))
		i += copy(dAtA[i:], m.PRUNE_BY)
	}
	if len(m.TABLE) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.TABLE)))
		i += copy(dAtA[i:], m.TABLE)
	}
	if m.PRINT_INFO {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.PRINT_INFO {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SAMPLES {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		if m.SAMPLES {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UPDATE_TABLE_INFO {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		if m.UPDATE_TABLE_INFO {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SKIP_OUTLIERS {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		if m.SKIP_OUTLIERS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ANOVA_ICC {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		if m.ANOVA_ICC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WRITE_BLOCK_INFO {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		if m.WRITE_BLOCK_INFO {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PROTO {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		if m.PROTO {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintInternal(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FlagDefs) Size() (n int) {
	var l int
	_ = l
	l = len(m.OP)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PRINT {
		n += 2
	}
	if m.EXPORT {
		n += 2
	}
	if m.LIST_TABLES {
		n += 2
	}
	if m.DECODE_FLAGS {
		n += 2
	}
	if m.ENCODE_FLAGS {
		n += 2
	}
	if m.ENCODE_RESULTS {
		n += 2
	}
	l = len(m.INT_FILTERS)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.STR_FILTERS)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.STR_REPLACE)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.SET_FILTERS)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.INTS)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.STRS)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.GROUPS)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.DISTINCT)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.TIME {
		n += 3
	}
	l = len(m.TIME_COL)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.TIME_BUCKET != 0 {
		n += 2 + sovInternal(uint64(m.TIME_BUCKET))
	}
	if m.HIST_BUCKET != 0 {
		n += 2 + sovInternal(uint64(m.HIST_BUCKET))
	}
	if m.LOG_HIST {
		n += 3
	}
	l = len(m.FIELD_SEPARATOR)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	l = len(m.FILTER_SEPARATOR)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.LOAD_AND_QUERY {
		n += 3
	}
	if m.READ_INGESTION_LOG {
		n += 3
	}
	if m.READ_ROWSTORE {
		n += 3
	}
	if m.SKIP_COMPACT {
		n += 3
	}
	if m.PROFILE {
		n += 3
	}
	if m.PROFILE_MEM {
		n += 3
	}
	if m.RECYCLE_MEM {
		n += 3
	}
	if m.CACHED_QUERIES {
		n += 3
	}
	l = len(m.WEIGHT_COL)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.LIMIT != 0 {
		n += 2 + sovInternal(uint64(m.LIMIT))
	}
	if m.DEBUG {
		n += 3
	}
	if m.JSON {
		n += 3
	}
	if m.GC {
		n += 3
	}
	l = len(m.DIR)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	l = len(m.SORT)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	l = len(m.PRUNE_BY)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	l = len(m.TABLE)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.PRINT_INFO {
		n += 3
	}
	if m.SAMPLES {
		n += 3
	}
	if m.UPDATE_TABLE_INFO {
		n += 3
	}
	if m.SKIP_OUTLIERS {
		n += 3
	}
	if m.ANOVA_ICC {
		n += 3
	}
	if m.WRITE_BLOCK_INFO {
		n += 3
	}
	if m.PROTO {
		n += 3
	}
	return n
}

func sovInternal(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInternal(x uint64) (n int) {
	return sovInternal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlagDefs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlagDefs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlagDefs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PRINT", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PRINT = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EXPORT", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EXPORT = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LIST_TABLES", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LIST_TABLES = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DECODE_FLAGS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DECODE_FLAGS = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ENCODE_FLAGS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ENCODE_FLAGS = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ENCODE_RESULTS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ENCODE_RESULTS = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field INT_FILTERS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.INT_FILTERS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field STR_FILTERS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.STR_FILTERS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field STR_REPLACE", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.STR_REPLACE = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SET_FILTERS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SET_FILTERS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field INTS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.INTS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field STRS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.STRS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GROUPS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GROUPS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DISTINCT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DISTINCT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TIME", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TIME = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TIME_COL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TIME_COL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TIME_BUCKET", wireType)
			}
			m.TIME_BUCKET = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TIME_BUCKET |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HIST_BUCKET", wireType)
			}
			m.HIST_BUCKET = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HIST_BUCKET |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LOG_HIST", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LOG_HIST = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FIELD_SEPARATOR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FIELD_SEPARATOR = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FILTER_SEPARATOR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FILTER_SEPARATOR = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LOAD_AND_QUERY", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LOAD_AND_QUERY = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field READ_INGESTION_LOG", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.READ_INGESTION_LOG = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field READ_ROWSTORE", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.READ_ROWSTORE = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKIP_COMPACT", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SKIP_COMPACT = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PROFILE", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PROFILE = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PROFILE_MEM", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PROFILE_MEM = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RECYCLE_MEM", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RECYCLE_MEM = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACHED_QUERIES", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CACHED_QUERIES = bool(v != 0)
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WEIGHT_COL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WEIGHT_COL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LIMIT", wireType)
			}
			m.LIMIT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LIMIT |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEBUG", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DEBUG = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JSON", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JSON = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GC = bool(v != 0)
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DIR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DIR = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SORT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SORT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PRUNE_BY", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PRUNE_BY = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TABLE", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TABLE = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PRINT_INFO", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PRINT_INFO = bool(v != 0)
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMPLES", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SAMPLES = bool(v != 0)
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UPDATE_TABLE_INFO", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UPDATE_TABLE_INFO = bool(v != 0)
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKIP_OUTLIERS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SKIP_OUTLIERS = bool(v != 0)
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ANOVA_ICC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ANOVA_ICC = bool(v != 0)
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WRITE_BLOCK_INFO", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WRITE_BLOCK_INFO = bool(v != 0)
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PROTO", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PROTO = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInternal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInternal
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInternal(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInternal = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInternal   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("internal.proto", fileDescriptorInternal) }

var fileDescriptorInternal = []byte{
	// 819 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x94, 0x51, 0x53, 0x1b, 0x37,
	0x10, 0x80, 0x63, 0x08, 0x60, 0xaf, 0xc1, 0x38, 0x6a, 0x9a, 0x2e, 0xa4, 0x31, 0x10, 0x42, 0xe3,
	0xa4, 0x84, 0x3c, 0xf4, 0x17, 0x9c, 0x75, 0xf2, 0xa1, 0x22, 0x9f, 0xae, 0x92, 0x5c, 0xca, 0x93,
	0x26, 0x74, 0x12, 0xca, 0x4c, 0x8a, 0x33, 0x29, 0xf9, 0x11, 0x7d, 0xeb, 0xcf, 0xca, 0x63, 0x9f,
	0xfb, 0x90, 0xe9, 0xd0, 0x3f, 0xd2, 0xd9, 0x95, 0xec, 0x32, 0x6d, 0x9f, 0xac, 0xfd, 0xf6, 0xf3,
	0xed, 0x49, 0xb7, 0x5a, 0xe8, 0x5d, 0x5e, 0x5d, 0xbf, 0x7e, 0x7f, 0xf5, 0xea, 0xed, 0xd1, 0xbb,
	0xf7, 0xb3, 0xeb, 0x99, 0x80, 0x79, 0xfc, 0xee, 0x7c, 0xfb, 0xc5, 0xc5, 0xe5, 0xf5, 0x4f, 0x1f,
	0xce, 0x8f, 0x7e, 0x9c, 0xfd, 0xfc, 0xf2, 0x62, 0x76, 0x31, 0x7b, 0xc9, 0xca, 0xf9, 0x87, 0x37,
	0x1c, 0x71, 0xc0, 0xab, 0xf4, 0xd7, 0xc7, 0xbf, 0x76, 0xa1, 0x3d, 0x7e, 0xfb, 0xea, 0xa2, 0x7c,
	0xfd, 0xe6, 0x17, 0xd1, 0x83, 0x25, 0xdb, 0x60, 0x6b, 0xb7, 0x35, 0xec, 0xb8, 0x25, 0xdb, 0x88,
	0xfb, 0xb0, 0xd2, 0x38, 0x5d, 0x07, 0x5c, 0xda, 0x6d, 0x0d, 0xdb, 0x2e, 0x05, 0xe2, 0x01, 0xac,
	0xaa, 0x1f, 0x1a, 0xeb, 0x02, 0x2e, 0x33, 0xce, 0x91, 0xd8, 0x81, 0xae, 0xd1, 0x3e, 0xc4, 0x50,
	0x8c, 0x8c, 0xf2, 0x78, 0x97, 0x93, 0x40, 0x28, 0x11, 0xb1, 0x07, 0xeb, 0xa5, 0x92, 0xb6, 0x54,
	0x71, 0x6c, 0x8a, 0xca, 0xe3, 0x0a, 0x1b, 0xdd, 0xc4, 0x18, 0x91, 0xa2, 0xea, 0x5b, 0xca, 0x6a,
	0x52, 0x12, 0x4b, 0xca, 0x01, 0xf4, 0xb2, 0xe2, 0x94, 0x9f, 0x9a, 0xe0, 0x71, 0x8d, 0xa5, 0x8d,
	0x44, 0x33, 0xa4, 0xb7, 0xd1, 0x75, 0x88, 0x63, 0x6d, 0x82, 0x72, 0x1e, 0xdb, 0xbc, 0x29, 0xd0,
	0x75, 0xc8, 0x84, 0x04, 0x1f, 0xdc, 0x42, 0xe8, 0x24, 0xc1, 0x07, 0xf7, 0x2f, 0xc1, 0xa9, 0xc6,
	0x14, 0x52, 0x21, 0x2c, 0x84, 0x4c, 0x58, 0x50, 0xff, 0x94, 0xe8, 0x66, 0x41, 0x2d, 0x4a, 0x08,
	0xb8, 0xab, 0xeb, 0xe0, 0x71, 0x9d, 0x33, 0xbc, 0x26, 0xe6, 0x83, 0xf3, 0xb8, 0x91, 0x18, 0xad,
	0xe9, 0x44, 0x2b, 0x67, 0xa7, 0x8d, 0xc7, 0x1e, 0xd3, 0x1c, 0x89, 0x6d, 0x68, 0x97, 0xda, 0x07,
	0x5d, 0xcb, 0x80, 0x9b, 0x9c, 0x59, 0xc4, 0xf4, 0x9c, 0xa0, 0x27, 0x0a, 0xfb, 0xbc, 0x79, 0x5e,
	0x8b, 0x2d, 0x68, 0xd3, 0x6f, 0x94, 0xd6, 0xe0, 0x3d, 0xf6, 0xd7, 0x28, 0x96, 0xd6, 0x88, 0x43,
	0xe8, 0x72, 0x6a, 0x34, 0x95, 0x27, 0x2a, 0xa0, 0xd8, 0x6d, 0x0d, 0x97, 0x47, 0xdd, 0x8f, 0x9f,
	0x76, 0xee, 0xfc, 0xf1, 0x69, 0x67, 0xf9, 0xf2, 0xea, 0xda, 0x01, 0xe5, 0x53, 0x9a, 0xec, 0x63,
	0xfa, 0x94, 0xd9, 0xfe, 0xec, 0x7f, 0x6c, 0xca, 0x67, 0x7b, 0x0b, 0xda, 0xc6, 0x56, 0x91, 0x08,
	0xde, 0xe7, 0xd7, 0x59, 0x33, 0xb6, 0xa2, 0x50, 0x3c, 0x85, 0xcd, 0xb1, 0x56, 0xa6, 0x8c, 0x5e,
	0x35, 0x85, 0x2b, 0x82, 0x75, 0xf8, 0x39, 0xbf, 0x58, 0x8f, 0xf1, 0x82, 0x8a, 0x67, 0xd0, 0x4f,
	0xa7, 0x76, 0xcb, 0x7c, 0xc0, 0xe6, 0x66, 0x3e, 0xcd, 0x85, 0xfa, 0x04, 0x7a, 0xc6, 0x16, 0x65,
	0x2c, 0xea, 0x32, 0x7e, 0x37, 0x55, 0xee, 0x0c, 0xbf, 0xe0, 0xa2, 0xeb, 0x44, 0x8b, 0xba, 0x64,
	0x26, 0x0e, 0x41, 0x38, 0x55, 0x94, 0x51, 0xd7, 0x95, 0xf2, 0x41, 0xdb, 0x3a, 0x1a, 0x5b, 0x21,
	0xb2, 0xd9, 0xa7, 0xcc, 0x22, 0x61, 0x6c, 0x25, 0xf6, 0x61, 0x83, 0x6d, 0x67, 0x4f, 0x7d, 0xb0,
	0x4e, 0xe1, 0x56, 0x7a, 0x24, 0xc1, 0x39, 0xa3, 0xe6, 0xf4, 0x27, 0xba, 0x89, 0xd2, 0x4e, 0x9a,
	0x42, 0x06, 0xdc, 0x4e, 0xcd, 0x49, 0x2c, 0x23, 0x81, 0xb0, 0xd6, 0x38, 0x3b, 0xd6, 0x46, 0xe1,
	0xc3, 0x74, 0x12, 0x39, 0xa4, 0x66, 0xc9, 0xcb, 0x38, 0x51, 0x13, 0xfc, 0x32, 0xdd, 0x8e, 0x8c,
	0x26, 0x6a, 0x42, 0x82, 0x53, 0xf2, 0x4c, 0x66, 0xe1, 0x51, 0x12, 0x32, 0x22, 0xe1, 0x00, 0x7a,
	0xb2, 0x90, 0xc7, 0x2a, 0xed, 0x5a, 0x2b, 0x8f, 0x83, 0xd4, 0xf8, 0x89, 0x66, 0x28, 0x1e, 0x01,
	0x9c, 0x2a, 0x5d, 0x1d, 0x07, 0x6e, 0x83, 0x1d, 0x3e, 0xc3, 0x4e, 0x22, 0xd4, 0x08, 0x7b, 0xb0,
	0x62, 0xf4, 0x44, 0x07, 0xdc, 0xfd, 0xef, 0x47, 0x4d, 0x19, 0xba, 0xf6, 0xa5, 0x1a, 0x4d, 0x2b,
	0xdc, 0x4b, 0xd7, 0x9e, 0x03, 0x6a, 0xb8, 0x6f, 0xbd, 0xad, 0xf1, 0x71, 0x6a, 0x38, 0x5a, 0xd3,
	0xc0, 0xa8, 0x24, 0xee, 0x33, 0x59, 0xaa, 0xa4, 0xe8, 0xc3, 0x72, 0xa9, 0x1d, 0x3e, 0xe1, 0xa2,
	0xb4, 0xe4, 0x76, 0xa7, 0x51, 0x71, 0x90, 0xdb, 0x9d, 0x06, 0xc5, 0x16, 0xb4, 0x1b, 0x37, 0xad,
	0x55, 0x1c, 0x9d, 0xe1, 0x57, 0xa9, 0x4d, 0x39, 0x1e, 0x9d, 0x51, 0x69, 0x1e, 0x16, 0xf8, 0x94,
	0x79, 0x0a, 0x68, 0x4b, 0x3c, 0x7a, 0xa2, 0xae, 0xc7, 0x16, 0x87, 0x5c, 0xae, 0xc3, 0x84, 0x00,
	0x1d, 0xba, 0x2f, 0x26, 0x0d, 0x0d, 0x9d, 0x67, 0xe9, 0xd0, 0x73, 0x28, 0x9e, 0xc3, 0xbd, 0x69,
	0x53, 0x16, 0x41, 0xa5, 0xa1, 0x94, 0xfe, 0xff, 0x9c, 0x9d, 0xcd, 0x94, 0x60, 0xce, 0x4f, 0xd9,
	0x87, 0x0d, 0xfe, 0xba, 0x76, 0x1a, 0x8c, 0xa6, 0xfb, 0xfc, 0x75, 0x6a, 0x01, 0x82, 0x73, 0x26,
	0x1e, 0x42, 0xa7, 0xa8, 0xed, 0xf7, 0x45, 0xd4, 0x52, 0xe2, 0x21, 0x0b, 0x6d, 0x06, 0x5a, 0x4a,
	0x31, 0x84, 0xfe, 0xa9, 0xd3, 0x41, 0xc5, 0x91, 0xb1, 0xf2, 0x24, 0x15, 0x7b, 0xc1, 0x4e, 0x8f,
	0x39, 0x63, 0xae, 0xc5, 0x83, 0xd5, 0x06, 0x8b, 0x47, 0xf3, 0xc1, 0x6a, 0x83, 0x1d, 0xf5, 0x3f,
	0xde, 0x0c, 0x5a, 0xbf, 0xdf, 0x0c, 0x5a, 0x7f, 0xde, 0x0c, 0x5a, 0xbf, 0xfd, 0x35, 0xb8, 0x73,
	0xbe, 0xca, 0x43, 0xfa, 0x9b, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x59, 0xd9, 0x7f, 0x20, 0xf1,
	0x05, 0x00, 0x00,
}
